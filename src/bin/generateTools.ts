#!/usr/bin/env node
import { program, Option } from 'commander';
import fs from 'fs';
import path from 'path';
import readline from 'readline';
import { LangtailEnvironment, LangtailPrompts } from '../LangtailPrompts';
import jsonSchemaToZod from 'json-schema-to-zod';
import packageJson from "../../package.json"

const SDK_VERSION = packageJson.version;
const TEMPLATE_PATH = new URL('./langtailTools.template.ts', import.meta.url);
const REPLACE_LINE = 'export const toolsObject = {};  // replaced by generateTools.ts'

interface FetchToolsOptions {
  workspace: string | undefined;
  project: string | undefined;
  promptSlug: string;
  environment: LangtailEnvironment;
  version: string | undefined;
}

interface Tools {
  [name: string]: {
    description: string;
    parameters: string;
  }
}

const fetchTools = async ({ workspace, project, promptSlug, environment, version }: FetchToolsOptions): Promise<Tools | undefined> => {
  const apiKey = process.env.LANGTAIL_API_KEY;
  if (!apiKey) {
    throw new Error('LANGTAIL_API_KEY environment variable is required');
  }

  const langtailPrompts = new LangtailPrompts({
    apiKey: apiKey,
    workspace: workspace,
    project: project,
  });

  const prompt = await langtailPrompts.get({
    prompt: promptSlug,
    environment: environment,
    version: version,
  });

  if (prompt.state.tools && prompt.state.tools.length > 0) {
    return Object.fromEntries(prompt.state.tools.map(tool => [
      tool.function.name, {
        description: tool.function.description,
        parameters: jsonSchemaToZod(tool.function.parameters)  // Parameters already serialized
      }
    ]));
  }
}

function askUserToConfirm(query: string): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  return new Promise(resolve => {
    rl.question(query, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

const prepareOutputFilePath = async (outputFile: string): Promise<string | undefined> => {
  let resultFilePath = outputFile;
  if (fs.existsSync(resultFilePath) && fs.statSync(resultFilePath).isDirectory()) {
    resultFilePath = path.join(resultFilePath, 'langtailTools.ts');
  }

  if (fs.existsSync(resultFilePath)) {
    const confirmed = await askUserToConfirm(`File ${resultFilePath} exists. Overwrite? [y/N]: `);
    if (!confirmed) {
      return;
    }
  }

  const directory = path.dirname(resultFilePath);
  if (!fs.existsSync(directory)) {
    const confirmed = await askUserToConfirm(`Directory ${directory} does not exist. Create it? [y/N]: `);
    if (confirmed) {
      fs.mkdirSync(directory, { recursive: true });
      console.log(`Created directory: ${directory}`);
    } else {
      return;
    }
  }

  return resultFilePath;
}

interface GenerateToolsOptions {
  out: string;
  workspace: string | undefined;
  project: string | undefined;
  env: LangtailEnvironment;
  ver: string | undefined;
}

const generateTools = async (promptSlug: string, { out, workspace, project, env, ver }: GenerateToolsOptions) => {
  const outputFile = await prepareOutputFilePath(out);
  if (!outputFile) {
    console.log('Operation cancelled by the user.');
    return;
  }

  let tools: Tools | undefined;
  try {
    tools = await fetchTools({ workspace, project, promptSlug, environment: env, version: ver });
  } catch (error) {
    if (error instanceof Error) {
      console.error(error.message);
    } else {
      console.error('Unexpected error:', error);
    }
    return;
  }

  if (!tools) {
    console.log(`No tools found for prompt ${promptSlug}`);
    return;
  }

  const fileInfo = '// ' + [
    `Langtail tools file`,
    `Generated at: ${new Date().toISOString()}`,
    `Langtail SDK Version: ${SDK_VERSION}`,
    workspace && `Workspace: ${workspace}`,
    project && `Project: ${project}`,
    `Prompt Slug: ${promptSlug}`,
    `Environment: ${env}`,
    ver && `Version: ${ver}`,
    ``
  ].filter(Boolean).join('\n// ') + '\n';

  const template = fs.readFileSync(TEMPLATE_PATH, 'utf8');
  const fileString = fileInfo + template.replace(REPLACE_LINE, `export const toolsObject = {\n${Object.entries(tools).map(([name, tool]) =>
    `  ${JSON.stringify(name)}: {\n    description: ${JSON.stringify(tool.description)},\n    parameters: ${tool.parameters}\n  }`).join(',\n')}\n};  // generated by generateTools.ts`);

  fs.writeFileSync(outputFile, fileString, 'utf8');
  console.log(`Tools data generated at ${outputFile}`);
}

function determineDefaultPath() {
  return fs.existsSync(path.join(process.cwd(), 'src')) ? 'src/langtailTools.ts' : 'langtailTools.ts';
}

program
  .version(SDK_VERSION)
  .option('--out [path]', 'output file path', determineDefaultPath())
  .addOption(new Option('--env [type]', 'Langtail environment').choices(['production', 'staging', 'preview']).default('production'))
  .option('--ver [number]', 'prompt version number')
  .option('--workspace [workspace]', 'Langtail workspace')
  .option('--project [project]', 'Langtail project')
  .argument('<promptSlug>', 'Langtail prompt slug')
  .action(generateTools);

program.parse(process.argv);
